#pragma config(Sensor, port2,  bumper,         sensorVexIQ_Touch)
#pragma config(Sensor, port6,  rightLS,        sensorNone)
#pragma config(Sensor, port7,  leftLS,         sensorNone)
#pragma config(Sensor, port8,  gyro,           sensorVexIQ_Gyro)
#pragma config(Motor,  motor1,          drift,         tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor3,          claw,          tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor4,          armright,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor5,          armleft,       tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor9,          leftDrive,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor10,         rightDrive,    tmotorVexIQ, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// The "TMotorType" values below have changed a bit between versions of RobotC.


int slew(int target, int curr, int rate) {
	int delta = target - curr;
	if (abs(delta) > rate) delta = rate*sgn(delta);
	return (curr + delta);
}

void setLeftMotor(int targetLeft, int time, int rate) {
	rate = abs(rate); //Make sure it is positive
	for (int i = 1; i < time; i+=10) {
		motor[leftDrive] = slew(targetLeft, motor[leftDrive], rate);
		wait1Msec(time); //Do not divide by i, the delay should be constant
	}
}

void setRightMotor(int targetLeft, int time, int rate) {
	rate = abs(rate); //Make sure it is positive
	for (int i = 1; i < time; i+=10) {
		motor[rightDrive] = slew(targetLeft, motor[rightDrive], rate);
		wait1Msec(time); //Do not divide by i, the delay should be constant
	}
}

void setHMotor(int targetLeft, int time, int rate) {
	rate = abs(rate); //Make sure it is positive
	for (int i = 1; i < time; i+=10) {
		motor[drift] = slew(targetLeft, motor[drift], rate);
		wait1Msec(time); //Do not divide by i, the delay should be constant
	}
}

void waitForTouch(){
	while(!getBumperValue(bumper))
	{
		sleep(25);
	}
}



#ifndef kRobotCVersionNumberic
#include <FirmwareVersion.h>

#if kRobotCVersionNumeric >= 400
#define tmotorVex269                    9989
#define tmotorVex393                    9990
#define tmotorVex393HighSpeed           9991
#else
#define tmotorVex269_HBridge            9992
#define tmotorVex269_MC29               9993
#define tmotorVex393_HBridge            9994
#define tmotorVex393_MC29               9995
#define tmotorVex393HighSpeed_HBridge   9996
#define tmotorVex393HighSpeed_MC29      9997
#endif
#if kRobotCVersionNumeric < 426
#define tmotorVex393TurboSpeed_HBridge  9998
#define tmotorVex393TurboSpeed_MC29     9999
#endif

#endif // kRobotCVersionNumeric

#define ticksPerRevIME269           240.448
#define ticksPerRevIME393           627.2
#define ticksPerRevIME393HighSpeed  392.0
#define ticksPerRevIME393TurboSpeed 261.333
#define ticksPerRevQuadEncoder      360.0

#define potentiometerMeasuredTicks    4095
#define potentiometerMeasuredDegrees  250.0

#define wheelDiameter2_75Inch                 2.75
#define wheelDiameter2_75InchOmni             2.75
#define wheelDiameter2_75InchOmniDoubleRoller 2.75
#define wheelDiameter3_85InchVEXplorer        3.85
#define wheelDiameter3_25Inch                 3.25
#define wheelDiameter3_25InchOmni             3.1875
#define wheelDiameter4Inch                    4.0
#define wheelDiameter4InchTraction            4.0
#define wheelDiameter4InchOmni                4.08
#define wheelDiameter4InchMecanum             4.0
#define wheelDiameter5Inch                    5.0
#define wheelDiameter6InchWheelLeg            6.0

const tMotor port[kNumbOfRealMotors] = {motor1, motor2, motor3, motor4, motor5, motor6, motor7, motor8, motor9, motor10,motor11,motor12};

// R = b/a, where "a" is the number of teeth on the sensor gear, and "b" is the number of teeth on the output gear.
const float sensorToOutputGearRatio[kNumbOfTotalMotors] = {0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3};

// Edit these constants to your robot's specs.
const tSensors kGyroPort = PORT8;
const float wheelDiameter = 2.5;
const unsigned char kNumWheels = 3;  // Number of drive wheels.
const unsigned char kNumMotorsPerWheel = 1;  // Max number of motors per wheel.
const tMotor kNone = (tMotor)-1;  // Used for indicating the lack of an additional motor.
const tMotor kDriveMotorPort[kNumWheels][kNumMotorsPerWheel] = {  // Drive motor ports/names.
	{motor9},  // Front-left.
	{drift},// Back-right.
	{motor10}
};
const unsigned char kNumDriveEncoders = 3;
const tMotor kDriveEncoderMotorPort[kNumDriveEncoders] = {motor9, drift, motor10};
// tankDrive: {90.0, -90.0} // hDrive: {90.0, 0.0, -90.0} // kiwiDrive: {60.0, -60.0, 180.0}
// xDrive OR mecanumDrive: {-135.0, 135.0, -45.0, 45.0} // plusDrive: {90.0, 0.0, -90.0, 180.0}
const float kDriveEncoderMotorAngle[kNumDriveEncoders] = {90.0, 0.0, -90.0};
const long kDefaultLoopDelay = 25;

float ticksPerRev[kNumbOfTotalMotors];

typedef struct {
	float x;
	float y;
	float t;
} coordinates;

typedef enum driveStyle {
	tankDrive = 0,
	hDrive = 1,
	kiwiDrive = 2,
	xDrive = 3,
	mecanumDrive = 4,
	plusDrive = 5,
};

const driveStyle kDriveType = hDrive;

coordinates currPos = {(coordinates)0.0, (coordinates)0.0, (coordinates)0.0};
coordinates destPos = {(coordinates)0.0, (coordinates)0.0, (coordinates)0.0};
coordinates diffPos = {(coordinates)0.0, (coordinates)0.0, (coordinates)0.0};

word maxDriveSpeed = 200;

const word trueSpeedArray[255] = {
	-127,-126,-121,-117,-108,-102,-101, -96, -87, -86,
	-85, -83, -83, -82, -81, -80, -75, -74, -73, -70,
	-69, -68, -67, -65, -63, -61, -60, -60, -56, -55,
	-54, -54, -51, -51, -51, -50, -49, -49, -48, -48,
	-48, -44, -44, -44, -43, -43, -39, -39, -38, -38,
	-37, -37, -37, -37, -36, -34, -34, -33, -32, -32,
	-31, -31, -31, -30, -30, -30, -29, -29, -29, -29,
	-28, -27, -27, -27, -26, -26, -26, -25, -25, -24,
	-24, -24, -23, -23, -22, -22, -22, -21, -21, -21,
	-20, -20, -20, -20, -20, -18, -18, -18, -18, -18,
	-18, -18, -17, -17, -17, -17, -16, -16, -16, -16,
	-16, -16, -14, -14, -14, -14, -14, -13, -13, -12,
	-12, -12, -12, -12, -11, -11, -11,   0,  11,  11,
	11,  12,  12,  12,  13,  13,  13,  13,  13,  14,
	14,  14,  14,  14,  14,  14,  15,  15,  15,  15,
	16,  16,  17,  17,  17,  18,  18,  18,  18,  18,
	20,  20,  20,  20,  19,  19,  19,  19,  21,  21,
	21,  21,  21,  21,  23,  23,  23,  23,  24,  24,
	24,  25,  25,  25,  26,  27,  27,  28,  28,  30,
	30,  30,  30,  31,  31,  31,  31,  32,  32,  33,
	34,  34,  35,  35,  36,  37,  37,  38,  38,  39,
	40,  40,  41,  42,  42,  43,  44,  45,  45,  46,
	47,  48,  49,  50,  51,  52,  53,  53,  54,  57,
	58,  59,  62,  63,  64,  67,  70,  70,  72,  74,
	76,  77,  78,  79,  83,  84,  86,  87,  90,  95,
	103, 111, 118, 124, 127
};

// Used to limit the input to the given bounds (max limit is ± if no min limit is given).
float limit(const float kInput, const float kMaxLimit, float minLimit = 2097200.0) {
	if(kInput > kMaxLimit) {
		return kMaxLimit;
	}
	if(minLimit == 2097200.0) {
		minLimit = -kMaxLimit;
	}
	if(kInput < minLimit) {
		return minLimit;
	}
	return kInput;
}

// Compensates for non-linearity of control value vs speed curve.
word trueSpeed(const long input) {
	const word speed = (word)limit(input, 127);

	return trueSpeedArray[speed + 127];
}

void saveTicksPerRev() {
	TSensorTypes motorSensorType = sensorNone;
	TMotorTypes motorSpeedType = tmotorNone;
	float ticksPerSensorRev = 0.0;

	for (unsigned char i = 0; i < kNumbOfTotalMotors; i++) {
		motorSensorType = SensorType[(port[i])];  // Sensor type.

		// Determine number of encoder ticks per revolution.

		ticksPerSensorRev = 360;


		ticksPerRev[i] = ticksPerSensorRev * sensorToOutputGearRatio[i];
	}
}


void resetEncoders() {
	resetMotorEncoder(leftDrive);
	resetMotorEncoder(rightDrive);
	resetMotorEncoder(drift);
}

void setXYT(float x, float y, float t) {
	destPos.x = x;
	destPos.y = y;
	destPos.t = t;
}

void moveX(float x){
	destPos.x += x;
}

void moveY(float y){
	destPos.y += y*1.2;
}

void moveAngle(float t){
	destPos.t += t;
}

void setAngle(float t){
	destPos.t = t;
}


void moveUpToLeftLine(){
	destPos.y +=3;
	sleep(500);
	while(true){
		writeDebugStreamLine("(%f)", SensorValue[leftLS]);
		if(SensorValue[leftLS] > 80){
			destPos.y +=1;
		}
		else{
			destPos.y = currPos.y-0.4;
			break;
		}
		sleep(10);
	}
}
void moveUpOnToLeftLine(){
	destPos.y +=3;
	sleep(500);
	while(true){
		writeDebugStreamLine("(%f)", SensorValue[leftLS]);
		if(SensorValue[leftLS] > 80){
			destPos.y +=1;
		}
		else{
			destPos.y = currPos.y-0.1;
			break;
		}
		sleep(5);
	}
}
void moveUpOnToRightLine(){
	destPos.y +=3;
	sleep(1000);
	while(true){

		if(SensorValue[rightLS] > 80){
			destPos.y +=1;
		}
		else{
			destPos.y = currPos.y+1;
			break;
		}
		sleep(10);
	}
}

void moveDownToRightLine(){
	destPos.y -=3;
	sleep(500);
	while(true){
		writeDebugStreamLine("(%f)", SensorValue[rightLS]);
		if(SensorValue[rightLS] > 100){
			destPos.y -=1;
		}
		else{
			destPos.y = currPos.y+1;
			break;
		}
		sleep(5);
	}
}
bool lockout = false;

bool slockout = false;

void moveDownToLeftLine(){
	destPos.y -=3;
	sleep(1000);
	while(true){

		if(SensorValue[leftLS] > 80){
			destPos.y -=1;
		}
		else{
			destPos.y = currPos.y+1;
			break;
		}
		sleep(10);
	}
}

float gyroOffset = 0.0;

task trackXYT() {
	const float kP = 30.0;//38.0;
	const float kI = 0;//0.5;
	const float kD = 0.2;//1.0;
	const float kL = 50.0;
	const float kRotationScale = 0.019;
	const long kLoopDelay = kDefaultLoopDelay;

	float gyroDegrees = 0.0;
	float lastGyro = 0.0;
	float tField = 0.0;
	float tFieldAvg = 0.0;
	float xField = 0.0;
	float yField = 0.0;
	float tEncoderField = 0.0;
	float radius = 0.0;
	float theta = 0.0;
	float robotX = 0.0;
	float robotY = 0.0;
	float error = 0.0;
	float prevError[kNumWheels];
	float p = 0.0;
	float i[kNumWheels];
	float d = 0.0;
	unsigned char xDivider = 0, yDivider = 0;
	word speed = 0;
	float encoderInches[kNumDriveEncoders];
	float lastEncoderInches[kNumDriveEncoders];
	float deltaEncoderInches[kNumDriveEncoders];

	for (unsigned char j = 0; j < kNumDriveEncoders; j++) {
		encoderInches[j] =
		lastEncoderInches[j] =
		deltaEncoderInches[j] = 0.0;
	}
	for (unsigned char j = 0; j < kNumWheels; j++) {
		prevError[j] =
		i[j] = 0.0;
	}

	if (kDriveType == tankDrive || kDriveType == xDrive || kDriveType == mecanumDrive || kDriveType == plusDrive) {
		xDivider = 2;
		yDivider = 2;
	}
	else if (kDriveType == hDrive || kDriveType == kiwiDrive) {
		xDivider = 1;
		if (kDriveType == hDrive) {
			yDivider = 2;
			} else {
			yDivider = 1;
		}
	}

	while (true) {
		// Save gyro and encoder values.
		gyroDegrees = SensorValue[gyro] ;
		for (unsigned char j = 0; j < kNumDriveEncoders; j++) {
			//encoderInches[j] = (nMotorEncoder[kDriveEncoderMotorPort[j]] / ticksPerRev[kDriveEncoderMotorPort[j]]) * PI * wheelDiameter;

			if(j==0){
				encoderInches[0] = (-nMotorEncoder[kDriveEncoderMotorPort[0]] / ticksPerRev[kDriveEncoderMotorPort[j]]) * PI * wheelDiameter;
			}

			if(j==1){
				encoderInches[1] = (nMotorEncoder[kDriveEncoderMotorPort[1]] / ticksPerRev[kDriveEncoderMotorPort[j]]) * PI * wheelDiameter;
			}
			if(j==2){
				encoderInches[2] = (-nMotorEncoder[kDriveEncoderMotorPort[2]] / ticksPerRev[kDriveEncoderMotorPort[j]]) * PI * wheelDiameter;
			}
		}

		tField = gyroOffset + gyroDegrees;  // Calculate degrees with respect to the field.
		tFieldAvg = gyroOffset + (gyroDegrees + lastGyro) / 2;  // Calculate average degrees for this movement.

		// Calculate (x,y) movement with respect to robot.
		xField = yField = 0.0;
		for (unsigned char j = 0; j < kNumDriveEncoders; j++) {
			deltaEncoderInches[j] = encoderInches[j] - lastEncoderInches[j];
			tEncoderField = kDriveEncoderMotorAngle[j] + tFieldAvg;  // Encoder degrees with respect to field.

			xField += deltaEncoderInches[j] * cosDegrees(tEncoderField);
			yField += deltaEncoderInches[j] * sinDegrees(tEncoderField);
		}
		xField /= xDivider;
		yField /= yDivider;

		// Update current position.
		currPos.x += xField;
		currPos.y += yField;
		currPos.t = tField;

		// Update difference from destination.
		diffPos.x = destPos.x - currPos.x;
		diffPos.y = destPos.y - currPos.y;
		diffPos.t = destPos.t - currPos.t;

		while (abs(diffPos.t) > 180) {
			diffPos.t -= sgn(diffPos.t) * 360;
		}

		// Convert from cartesian to polar.
		radius = sqrt(pow(diffPos.x, 2) + pow(diffPos.y, 2));  // r^2 = x^2 + y^2
		theta = atan2(diffPos.y, diffPos.x) * 180 / PI;  // tan(t) = y/x (Then converted from radians to degrees.)

		// Subtract robot angle to get difference with respect to robot.
		theta -= tField;
		robotX = radius * cosDegrees(theta);
		robotY = radius * sinDegrees(theta);

		// PID for moving to destination.
		for (unsigned char j = 0; j < kNumWheels; j++) {
			error = limit(robotX * cosDegrees(kDriveEncoderMotorAngle[j]), maxDriveSpeed / kP)
			+ limit(robotY * sinDegrees(kDriveEncoderMotorAngle[j]), maxDriveSpeed / kP)
			+ limit(diffPos.t * kRotationScale, maxDriveSpeed / (kP*1.1));

			p = error;
			i[j] = limit(i[j] + error, kL);
			d = error - prevError[j];

			speed = trueSpeed(limit((kP * p) + (kI * i) + (kD * d), maxDriveSpeed));

			if(j ==0 && !lockout){
				setMotorSpeed(rightDrive,speed);
				//setLeftMotor(speed,1,20);
			}
			if(j==1 && !slockout){
				setHMotor(speed,5,20);
				//	setMotorSpeed(drift,speed*1.1);
			}
			if(j==2 && !lockout){
				//setRightMotor(speed,1,20);
				setMotorSpeed(leftDrive,speed);
			}
			//	setMotorSpeed(kDriveMotorPort[j][0],speed);
			//writeDebugStreamLine("(%f,%f)", diffPos.t, speed);


			prevError[j] = error;
		}

		// Update "last" sensor reading variables.
		for (unsigned char j = 0; j < kNumDriveEncoders; j++) {
			lastEncoderInches[j] = encoderInches[j];
		}
		lastGyro = gyroDegrees;

		sleep(kLoopDelay);
	}
}

task trackXYT2() {
	const float kP = 30.0;//38.0;
	const float kI = 0;//0.5;
	const float kD = 0.2;//1.0;
	const float kL = 50.0;
	const float kRotationScale = 0.019;
	const long kLoopDelay = kDefaultLoopDelay;

	float gyroDegrees = 0.0;
	float lastGyro = 0.0;
	float tField = 0.0;
	float tFieldAvg = 0.0;
	float xField = 0.0;
	float yField = 0.0;
	float tEncoderField = 0.0;
	float radius = 0.0;
	float theta = 0.0;
	float robotX = 0.0;
	float robotY = 0.0;
	float error = 0.0;
	float prevError[kNumWheels];
	float p = 0.0;
	float i[kNumWheels];
	float d = 0.0;
	unsigned char xDivider = 0, yDivider = 0;
	word speed = 0;
	float encoderInches[kNumDriveEncoders];
	float lastEncoderInches[kNumDriveEncoders];
	float deltaEncoderInches[kNumDriveEncoders];

	for (unsigned char j = 0; j < kNumDriveEncoders; j++) {
		encoderInches[j] =
		lastEncoderInches[j] =
		deltaEncoderInches[j] = 0.0;
	}
	for (unsigned char j = 0; j < kNumWheels; j++) {
		prevError[j] =
		i[j] = 0.0;
	}

	if (kDriveType == tankDrive || kDriveType == xDrive || kDriveType == mecanumDrive || kDriveType == plusDrive) {
		xDivider = 2;
		yDivider = 2;
	}
	else if (kDriveType == hDrive || kDriveType == kiwiDrive) {
		xDivider = 1;
		if (kDriveType == hDrive) {
			yDivider = 2;
			} else {
			yDivider = 1;
		}
	}

	while (true) {
		// Save gyro and encoder values.
		gyroDegrees = SensorValue[gyro] ;
		for (unsigned char j = 0; j < kNumDriveEncoders; j++) {
			//encoderInches[j] = (nMotorEncoder[kDriveEncoderMotorPort[j]] / ticksPerRev[kDriveEncoderMotorPort[j]]) * PI * wheelDiameter;

			if(j==0){
				encoderInches[0] = (-nMotorEncoder[kDriveEncoderMotorPort[0]] / ticksPerRev[kDriveEncoderMotorPort[j]]) * PI * wheelDiameter;
			}

			if(j==1){
				encoderInches[1] = (nMotorEncoder[kDriveEncoderMotorPort[1]] / ticksPerRev[kDriveEncoderMotorPort[j]]) * PI * wheelDiameter;
			}
			if(j==2){
				encoderInches[2] = (-nMotorEncoder[kDriveEncoderMotorPort[2]] / ticksPerRev[kDriveEncoderMotorPort[j]]) * PI * wheelDiameter;
			}
		}

		tField = gyroOffset + gyroDegrees;  // Calculate degrees with respect to the field.
		tFieldAvg = gyroOffset + (gyroDegrees + lastGyro) / 2;  // Calculate average degrees for this movement.

		// Calculate (x,y) movement with respect to robot.
		xField = yField = 0.0;
		for (unsigned char j = 0; j < kNumDriveEncoders; j++) {
			deltaEncoderInches[j] = encoderInches[j] - lastEncoderInches[j];
			tEncoderField = kDriveEncoderMotorAngle[j] + tFieldAvg;  // Encoder degrees with respect to field.

			xField += deltaEncoderInches[j] * cosDegrees(tEncoderField);
			yField += deltaEncoderInches[j] * sinDegrees(tEncoderField);
		}
		xField /= xDivider;
		yField /= yDivider;

		// Update current position.
		currPos.x += xField;
		currPos.y += yField;
		currPos.t = tField;

		// Update difference from destination.
		diffPos.x = destPos.x - currPos.x;
		diffPos.y = destPos.y - currPos.y;
		diffPos.t = destPos.t - currPos.t;

		while (abs(diffPos.t) > 180) {
			diffPos.t -= sgn(diffPos.t) * 360;
		}

		// Convert from cartesian to polar.
		radius = sqrt(pow(diffPos.x, 2) + pow(diffPos.y, 2));  // r^2 = x^2 + y^2
		theta = atan2(diffPos.y, diffPos.x) * 180 / PI;  // tan(t) = y/x (Then converted from radians to degrees.)

		// Subtract robot angle to get difference with respect to robot.
		theta -= tField;
		robotX = radius * cosDegrees(theta);
		robotY = radius * sinDegrees(theta);

		// PID for moving to destination.
		for (unsigned char j = 0; j < kNumWheels; j++) {
			error = limit(robotX * cosDegrees(kDriveEncoderMotorAngle[j]), maxDriveSpeed / kP)
			+ limit(robotY * sinDegrees(kDriveEncoderMotorAngle[j]), maxDriveSpeed / kP)
			+ limit(diffPos.t * kRotationScale, maxDriveSpeed / (kP*1.1));

			p = error;
			i[j] = limit(i[j] + error, kL);
			d = error - prevError[j];

			speed = trueSpeed(limit((kP * p) + (kI * i) + (kD * d), maxDriveSpeed));

			if(j ==0 && !lockout){
				setMotorSpeed(rightDrive,speed);
				//setLeftMotor(speed,1,20);
			}
			if(j==1 && !slockout){
				setHMotor(speed,5,20);
				//	setMotorSpeed(drift,speed*1.1);
			}
			if(j==2 && !lockout){
				//setRightMotor(speed,1,20);
				setMotorSpeed(leftDrive,speed);
			}
			//	setMotorSpeed(kDriveMotorPort[j][0],speed);
			//writeDebugStreamLine("(%f,%f)", diffPos.t, speed);


			prevError[j] = error;
		}

		// Update "last" sensor reading variables.
		for (unsigned char j = 0; j < kNumDriveEncoders; j++) {
			lastEncoderInches[j] = encoderInches[j];
		}
		lastGyro = gyroDegrees;

		sleep(kLoopDelay);
	}
}

void armup(){
	setMotorTarget(armleft,380,100);
	setMotorTarget(armright,380,100);
}

void armPlace(){
	//reduce motor speed to 35 from 50
	setMotorTarget(armleft,260,35);
	setMotorTarget(armright,260,35);
}


void armDown(){
	setMotorTarget(armleft,0,100);
	setMotorTarget(armright,0,100);
}

task main() {

	setMotorCurrentLimit(drift,1000);
	//setMotorCurrentLimit(leftDrive,700);
	//setMotorCurrentLimit(rightDrive,700);
	//calibrateGyro();
	waitForTouch();
	resetEncoders();
	saveTicksPerRev();
	resetGyro(gyro);
	startTask(trackXYT);

// START of CODING Distances for IQ RISE ABOVE RIGHT SIDE OF THE FIELD //

	//	setXYT(10,10,0);

	//Turn right to push first riser in the goal
	maxDriveSpeed = 200;

	lockout = true;
	moveX(21.5);
	// change from 300 - 100
	sleep(2000);
	moveX(-7.5);
	sleep(800);//1000
	lockout = false;
	//moveY(3);
	moveY(8.9);
	sleep(1400);//1500
	setAngle(-90);
	sleep(1700); //1800

	// Go and pickup stack for first goal

	maxDriveSpeed = 200;
	moveX(16.8);
	sleep(400);

	setMotorTarget(claw,300,100);
	sleep(800);
	armup();
	sleep(100);

	//Turn and place stack on the first goal

	moveAngle(-26);
	sleep(700);
	moveX(7.8);
	moveY(-3.8);
	sleep(800);
	armPlace();
	sleep(500);
	setMotorTarget(claw,0,100);
	sleep(500);

	// Move back

	moveX(-22);
	sleep(500);
	armDown();
	sleep(800);
	setAngle(-90);
  sleep(900); //1000

	// Move in the centre of the Orange and Purple riser


	//moveX(-11);
	//sleep(1500);
	moveY(11.8);
	sleep(1700); //1800


	// Push purple fwd in middle goal

	moveX(17.7);
	sleep(1000);

	// Move to the third goal

	maxDriveSpeed = 200;
	moveX(-21.2);
	sleep(1400); //1500
	moveY(13);
	sleep(1800);

	//Push Purple in the 3rd goal

	setAngle(-90);
	//sleep(1000);
	moveX(20); //19.7
	sleep(1500); //1000
	moveX(-15);
	sleep(800);
	setAngle(-90);
	sleep(1000);

//	// Align to pickup stack for 3rd goal

	moveY(-3.6);
	sleep(1000);

//	//moveDownToRightLine();


	maxDriveSpeed = 200;
	moveX(22);
	sleep(500);
	setMotorTarget(claw,300,100);
	sleep(550);
	armup();
	sleep(50);
	moveAngle(26);
	sleep(700);
	moveX(6); //5.8
	moveY(2.8);
	sleep(1000);
	armPlace();
	sleep(500);
	setMotorTarget(claw,0,100);
	sleep(500);
	moveX(-20); //-10
	sleep(800);
	maxDriveSpeed = 200;
	armDown();

	// Move back to the starting position

	setAngle(-90);
	moveY(-25);
	//setXYT(0,0,0);
	sleep(2000);





}
